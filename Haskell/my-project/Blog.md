# Haskell

Dit is voor het eerst dat ik in aanraking kom met een functionele programmeer taal. Voor de eerste keer heb ik Haskell gekozen. Ik heb Haskell gekozen, omdat ik er vaak van heb gehoord en het is volgens velen de puurste vorm van functioneel programmeren. Als ik functioneel voor het eerst doe, dan maar gelijk puur functioneel.

## Dag 1

De eerste dag en voor het eerst in aanraking gekomen met functioneel programmeren en dus ook Haskell. De eerste dag heb ik uit het boek Seven Languages in Seven Weeks gevolgd om al een idee van de basis te krijgen voor Haskell.

Voordat ik kon beginnen moest ik Haskell eerst installeren voor Windows. Dit was niet moeilijk en ik kon snel aan de slag. Ik begon eerst in de console de basisvoorbeelden door te nemen en dat sprak allemaal nog voor zich. Het moment dat het boek begon over functies ging ik een manier zoeken om Haskell bestanden aan te roepen. Dit was wat anders dan ik gewend was, omdat je zelf via de command line de bestanden moet aanroepen. Ik deed het via GHCI, waarmee ik dan weer afzonderlijke functies in het Haskell bestand kon aanroepen. Dit is even wennen, omdat ik normaal gesproken unit tests gebruik en bij intellij of visual studio is dat 1 shortcut en het werkt.

Op naar de taal zelf. Het eerste waar ik heel erg aan moest wennen was de syntax. Haakjes zijn niet nodig om functies uit te voeren. Hierdoor zat ik bij de eerste recursive functie te kijken van: "wat gebeurt hier nou", maar ik had toen gewoon even niet door dat een functie ook werkt zonder haakjes. Ik moest ook erg wennen aan de manier waarop functies gedefinieerd worden en aan pattern matching.

Tuples kende ik al vanuit C# dus dat is niet nieuw en lists zijn ook niet echt spannend.

## Dag 2

Bij Dag 2 van het seven languages boek was het niet moeilijk om de aspecten van Higher-Order Functions, Partially Applied Functions and Currying, and Lazy Evalution te begrijpen. Het begrijpen van de concepten was niet moeilijk, maar het toepassen van de concepten was een stuk moeilijker dan ik dacht. Dit kwam mede door de syntax van Haskell waar ik super veel moeite mee heb om aan te wennen. Dit leverde veel frustratie op. Vooral bij de opdracht van "Write a Haskell function to convert a string to a number. The string should be in the form of $2,345,678.99 and can possibly have leading zeros.". Hiervoor had ik uiteindelijk de oplossing op het internet gezocht. Deze oplossing werkte ook nog niet helemaal, omdat die door komma's in de tekst eruit klapte. Dit heb ik uiteindelijk opgelost door komma's weg te filteren uit de tekst. Deze fout zorgde er wel voor datik de documentatie beter ben gaan begrijpen en de syntax structuur van Haskell.

De opdrachten daarna gingen mij een stuk beter af en ik moest alleen nog weer heel erg wennen aan de head:tail structuur. Omdat ik niet gewend ben om zoiets te gebruiken had ik nog wat moeite met de denominator opdracht. Ik had dit eerst gemaakt met guards, maar op 1 of andere manier werd de list niet aangevuld en gaf die een lege list terug. De guards had ik uiteindelijk omgezet naar een if then else constructie en toen werd de list wel gewoon aangevuld met de waardes.

Al om al was het een deels frustrerende tweede dag, waarbij ik wel veel heb geleerd over de syntax en handige snufjes van Haskell.

## Dag 3

De laatste dag uit het boek. Classes and Types en Monads wat door veel mensen wordt gezien als verwarrend. Het eerste gedeelte wat ik heb doorgelezen was het Classes and Types hoofdstuk. Hier heb ik dingen geleerd over types, User-Defined Types, Functions and Polymorphism, recursive types en Classes. Toen ik eraan begon voelde dit voor mij al wel redelijk vertrouwd het deed me namelijk heel erg veel denken aan java classes. Vooral het polymorphisme gedeelte met het implementeren van andere classes voor, zodat bijvoorbeeld equality geimplementeerd kan worden voor de class. Types lieten mij ook erg veel denken aan types in java. In Haskell werkt het dan wel iets anders, er zijn namelijk recursive types en ik herinner mij niet dat dat concept in Java is voorbij gekomen. Het zal vast wel mogelijk zijn om zon recursive type te implementeren in Java, maar het concept zelf is nog nooit naar boven gekomen.

Het moeilijkste gedeelte om te begrijpen was sowieso Monads. Op basis van wat ik allemaal heb gelezen geloof ik dat Monads een systeem is, waarmee functies uitgevoerd kunnen worden op dezelfde state van een variabele. Dus dat functies effect veranderingen uitvoerd op dezelfde variabele. Nu ik dit zo heb geschreven doet het me heel erg denken aan pipes and filters, want daar wordt de data ook telkens doorgegeven en veranderd totdat het gereturned wordt. Voortbouwend op de Monads is er ook nog syntactic sugar voor het gebruiken van Monads, namelijk de do Notation. Door de do notation voelt het programmeren al een stuk meer imperatief. Dit komt omdat er een aantal statements onder elkaar staan met een return op het einde. Eigenlijk zoals functies in Java die bijvoorbeeld een String returnen.

Ook is er nog dieper ingegaan op een aantal verschillende types van Monads. Voornamelijk de list Monad en de Maybe Monad. De list Monad vond ik in het begin moeilijk te begrijpen, maar het idee is dat er non-deterministische problemen mee opgelost kunnen worden. Door de list Monad te gebruiken is het mogelijk om elke mogelijke combinatie van de list te verkrijgen. Hier zou bijvoorbeeld een password cracker gemaakt kunnen worden, zoals bassaal is gedaan in het boek. De Maybe Monad is best wel simpel. Met de maybe Monad kan er afgevangen worden dat functies falen. Zo heb ik het begrepen. Dus als het niet goed gaat kan er nothing gereturned worden en anders gewoon de value. De Maybe Monad kan gebruikt worden als wrapper, zodat het niet helemaal zelf uitgeprogrammeerd hoeft te worden.

Uiteindelijk is er natuurlijk ook nog het self study gedeelte. Ik vond dit gedeelte niet super goed uitgelegd. De eerste vraag was nogal onduidelijk met wat het nou precies wou. Met name de text "Write a hash that stores other hashes". Ik had geen idee wat hiermee werd bedoeld en daarom zocht ik het op, op internet. Hier waren mensen ook al in de war met wat er precies bedoeld werd met de opdracht. Uiteindelijk heb ik de opdracht maar geskipt en ben ik overgegaan naar de duidelijke, maar wel lastige opdracht van het maken van een Maze en die te solven met een list Monad. Dat maken van de Maze was neit moeilijk maar het solven wel. Ik heb de opdracht opgelost door elke combinatie mogelijk langs te gaan tot dat er ergens een pad is naar de finish. Hier was ik best wel lang mee bezig, maar hierdoor heb ik wel beter geleerd hoe de list Nomad werkt en hoe de syntax van Haskell werkt met de do Notation. Dit was het laatste wat ik had gedaan voor dag 3 en als laatste ga ik nog mijn eigen challenge maken. Een procedurally generated "dungeon".